

# ⚙️ Apex 异步处理：Apex Batch

---

## 🧩 一、Apex Batch 是什么？

在 Salesforce 中，如果你一次性要处理成千上万条记录（例如更新所有 Account、计算积分、导入数据等），
普通的 `for` 循环就会遇到 **Governor Limit（治理限制）**。

**Apex Batch** 就是 Salesforce 提供的“分批执行器”——
它能把海量数据拆分成小块分批执行，每一块都有自己独立的上下文，不会互相影响。

---

### 🧠 生活比喻：

想象你要搬一栋大楼的 10,000 箱货。

* 普通 Apex：你一个人试图一次搬完 💥（被限制，失败）
* Apex Batch：你派了 200 个工人，每人搬 50 箱 ✅（分批执行，效率高、安全）

---

## 🧱 二、Apex Batch 的结构与接口

Apex Batch 是通过 **实现 `Database.Batchable<T>` 接口** 来实现的。
接口规定你必须写出 3 个方法：

| 方法                                                     | 作用            | 必须实现？ |
| ------------------------------------------------------ | ------------- | ----- |
| `start(Database.BatchableContext bc)`                  | 定义要处理的数据范围    | ✅     |
| `execute(Database.BatchableContext bc, List<T> scope)` | 定义每批次如何处理数据   | ✅     |
| `finish(Database.BatchableContext bc)`                 | 所有批次执行完后的收尾操作 | ✅     |

---

## ✅ 三、代码结构示例

假设我们要批量更新所有 `Account`，把 `Active__c` 字段设为 `true`。

```apex
public class ActivateAccountsBatch implements Database.Batchable<SObject> {

    // 1️⃣ start：定义要处理的数据集
    public Database.QueryLocator start(Database.BatchableContext bc) {
        System.debug('🚀 开始批处理');
        return Database.getQueryLocator([
            SELECT Id, Name, Active__c FROM Account WHERE Active__c = false
        ]);
    }

    // 2️⃣ execute：定义每一批的处理逻辑
    public void execute(Database.BatchableContext bc, List<Account> scope) {
        System.debug('📦 正在处理 ' + scope.size() + ' 条 Account');
        for (Account acc : scope) {
            acc.Active__c = true;
        }
        update scope;
    }

    // 3️⃣ finish：定义所有批次处理完之后的逻辑
    public void finish(Database.BatchableContext bc) {
        System.debug('✅ 批处理全部完成');
    }
}
```

---

### 🔹 调用方式

在匿名窗口（Developer Console → Execute Anonymous）中运行：

```apex
ActivateAccountsBatch batch = new ActivateAccountsBatch();
Database.executeBatch(batch, 200); // 每批处理 200 条记录
```

---

## 🧠 四、三个方法的执行流程

| 步骤  | 方法          | 描述                          |
| --- | ----------- | --------------------------- |
| 1️⃣ | `start()`   | 定义要处理的范围（SOQL 查询或 Iterable） |
| 2️⃣ | `execute()` | 每次处理一批记录（默认 200 条）          |
| 3️⃣ | `finish()`  | 全部完成后触发，可发送通知或触发另一个 Batch   |

---

## 💬 五、常见场景举例

| 场景    | 示例           |
| ----- | ------------ |
| 清理旧数据 | 删除超过一年未活跃的记录 |
| 大规模更新 | 批量计算积分、更新字段  |
| 异步调用  | 调用外部系统 API   |
| 数据修复  | 批量修改错误字段值    |

---

## 🧩 六、Apex Batch 与接口的关系

在上一章我们讲过接口（`interface`）定义“规范”。
Apex Batch 就是 Salesforce 内置接口的一种典型应用。

```apex
public class MyBatch implements Database.Batchable<SObject> {
    // 实现接口要求的三个方法
    public Database.QueryLocator start(Database.BatchableContext bc) {...}
    public void execute(Database.BatchableContext bc, List<SObject> scope) {...}
    public void finish(Database.BatchableContext bc) {...}
}
```

也就是说：

> 🧠 “你实现了 Salesforce 官方的 Batchable 接口，就必须写完这三个方法。”

这就是面向对象中 **“接口规定行为、类提供实现”** 的具体体现。

---

## 🚧 七、Apex Batch 的限制（Governor Limits）

| 限制项          | 说明                                                          |
| ------------ | ----------------------------------------------------------- |
| 每个批次的最大执行记录数 | 默认 200，可在 `Database.executeBatch(batch, size)` 中设置，最大 2,000 |
| 同时活跃的批任务     | 每个 org 最多 5 个活跃批处理任务                                        |
| 最大队列等待数      | 最多 100 个挂起的批任务                                              |
| 异常抛出         | 如果批次失败，不影响其他批次（事务独立）                                        |
| 调用链限制        | Batch 中不能直接调用另一个 Batch（需在 `finish()` 中调度）                   |
| DML/Query 限制 | 每批独立计算治理限制，不累积                                              |
| 测试覆盖率        | 测试类必须调用 `Database.executeBatch()` 来覆盖逻辑                     |

---

## ⚠️ 八、常见注意事项与坑

| 注意点                           | 原因与解释                                          |
| ----------------------------- | ---------------------------------------------- |
| ❌ 不要在 `start()` 中写太重逻辑        | 这个阶段仅用于定义数据范围                                  |
| ✅ DML 和 SOQL 放在 `execute()` 中 | 每批独立运行，安全不超限                                   |
| ⚠️ `scope` 可能为空               | 批次被过滤或错误时需判空处理                                 |
| ✅ 批次之间是独立事务                   | 某一批失败不会影响其他批次                                  |
| ⚠️ finish() 中执行 DML 仍受限       | 它是单独事务，需控制操作量                                  |
| ✅ 支持链式调用                      | 可在 `finish()` 调用下一个 Batch 或 Queueable          |
| ⚠️ 不要直接用 Trigger 调 Batch      | 容易造成异步调用叠加，建议用异步控制类调用                          |
| ⚠️ 不能用 Future 调 Batch         | 会抛出 “Future methods cannot call batch jobs” 异常 |

---

## 🔄 九、进阶：链式批处理（Chaining）

有时你需要在一个批处理完成后执行另一个批处理，可以在 `finish()` 中调用下一个：

```apex
public class FirstBatch implements Database.Batchable<SObject> {
    public Database.QueryLocator start(Database.BatchableContext bc) {
        return Database.getQueryLocator([SELECT Id FROM Account]);
    }
    public void execute(Database.BatchableContext bc, List<Account> scope) {
        System.debug('执行第一批任务...');
    }
    public void finish(Database.BatchableContext bc) {
        System.debug('第一批结束，启动下一批');
        Database.executeBatch(new SecondBatch(), 100);
    }
}

public class SecondBatch implements Database.Batchable<SObject> {
    public Database.QueryLocator start(Database.BatchableContext bc) {
        return Database.getQueryLocator([SELECT Id FROM Contact]);
    }
    public void execute(Database.BatchableContext bc, List<Contact> scope) {
        System.debug('执行第二批任务...');
    }
    public void finish(Database.BatchableContext bc) {
        System.debug('第二批全部完成 ✅');
    }
}
```

---

## 🧠 十、与 Queueable 和 Future 的比较

| 类型          | 是否异步 | 可处理数据量 | 可链式调用 | 支持返回值 | 场景          |
| ----------- | ---- | ------ | ----- | ----- | ----------- |
| `@future`   | ✅    | 小量数据   | ❌     | ❌     | 轻量任务、API 调用 |
| `Queueable` | ✅    | 中量数据   | ✅     | ✅     | 异步复杂逻辑      |
| `Batchable` | ✅    | 大量数据   | ✅     | ❌     | 海量记录处理      |

---

## ✅ 十一、最佳实践总结

| 建议                                                   | 原因            |
| ---------------------------------------------------- | ------------- |
| ✔️ 永远用 `Database.Stateful` 保持状态                      | 跨批次保存变量（如计数器） |
| ✔️ 在 `finish()` 中发邮件或执行链式批处理                         | 实现任务串联        |
| ❌ 不要用 `System.abortJob()` 随意中止任务                     | 容易造成数据不一致     |
| ✔️ 日志和错误捕获要健全                                        | 否则失败难追踪       |
| ✔️ 保持批次粒度合理（200-500）                                 | 性能与治理平衡       |
| ✔️ 测试类务必使用 `Test.startTest()` / `Test.stopTest()` 包裹 | 触发异步执行        |

---

## 🧩 十二、Stateful 示例（跨批次统计）

```apex
public class CountAccountsBatch implements Database.Batchable<SObject>, Database.Stateful {
    public Integer totalProcessed = 0;

    public Database.QueryLocator start(Database.BatchableContext bc) {
        return Database.getQueryLocator([SELECT Id FROM Account]);
    }

    public void execute(Database.BatchableContext bc, List<Account> scope) {
        totalProcessed += scope.size();
        System.debug('本批处理 ' + scope.size() + ' 条记录');
    }

    public void finish(Database.BatchableContext bc) {
        System.debug('🎯 总共处理了 ' + totalProcessed + ' 条记录');
    }
}
```

> 🔸 加上 `Database.Stateful` 后，类中的成员变量在多个批次之间会保留。

---

## 🧾 十三、总结一句话记忆：

| 关键词                | 记忆口诀                             |
| ------------------ | -------------------------------- |
| **Batchable 接口**   | “我规定 3 件事：start、execute、finish。” |
| **Governor Limit** | “每批单独算限额，互不影响。”                  |
| **Stateful**       | “我记得我做了多少。”                      |
| **Chaining**       | “做完一件事，接着做下一件。”                  |
| **适用场景**           | “当你要处理超过 10,000 条记录时，用 Batch。”   |


