
# 🚀 Apex虚拟类、抽象类与接口

---

## 🧩 一、Virtual Class（虚拟类）

### 💡 概念

* `virtual` 类表示“可以继承的普通类”。
* 它自己能用，也允许别人改造。
* 类中标记为 `virtual` 的方法可以被子类 `override`。

---

### 🧠 生活比喻

想象你开了一家“外卖公司”：

* 公司提供一个**通用配送员模板（Virtual Class）**。
* 普通员工可以直接用，也可以让分公司“自定义配送逻辑”。

---

### ✅ 示例：通用订单处理器

```apex
public virtual class OrderProcessor {
    public String orderId { get; set; }

    public OrderProcessor(String id) {
        this.orderId = id;
    }

    // virtual 表示允许子类修改实现
    public virtual void processOrder() {
        System.debug('🧾 正在处理订单：' + orderId);
    }

    public void confirmDelivery() {
        System.debug('✅ 订单 ' + orderId + ' 已送达');
    }
}
```

#### 子类：不同渠道自定义订单逻辑

```apex
public class OnlineOrderProcessor extends OrderProcessor {
    public OnlineOrderProcessor(String id) {
        super(id);
    }

    public override void processOrder() {
        System.debug('💻 正在处理线上订单：' + orderId);
    }
}

public class StoreOrderProcessor extends OrderProcessor {
    public StoreOrderProcessor(String id) {
        super(id);
    }

    public override void processOrder() {
        System.debug('🏪 正在处理门店订单：' + orderId);
    }
}
```

#### 调用：

```apex
List<OrderProcessor> orders = new List<OrderProcessor>{
    new OnlineOrderProcessor('O-1001'),
    new StoreOrderProcessor('S-2002')
};

for (OrderProcessor o : orders) {
    o.processOrder();
    o.confirmDelivery();
}
```

输出：

```
💻 正在处理线上订单：O-1001
✅ 订单 O-1001 已送达
🏪 正在处理门店订单：S-2002
✅ 订单 S-2002 已送达
```

---

### 🔹 什么时候使用 Virtual Class？

| 场景                | 说明                |
| ----------------- | ----------------- |
| 1️⃣ 各分支逻辑共用一套基础结构 | 不同业务类型的订单、报告、计算逻辑 |
| 2️⃣ 需要可扩展的“父类模板”  | 在不同环境下改写方法        |
| 3️⃣ 想支持“多态调用”     | 父类引用指向不同子类实例      |

---

## 🧩 二、Abstract Class（抽象类）

### 💡 概念

* **不能实例化**，只能被继承。
* 定义“必须实现的方法”。
* 一部分逻辑可以写在抽象类中，一部分留给子类实现。

---

### 🧠 生活比喻

抽象类就像是**公司制度手册** 📘。
它规定：所有员工都必须会做某些事（比如签到、报告），
但具体怎么做，由不同岗位（子类）决定。

---

### ✅ 示例：通知发送系统

```apex
public abstract class NotificationService {
    public String recipient { get; set; }

    public NotificationService(String r) {
        this.recipient = r;
    }

    // 已实现的公共逻辑
    public void prepareMessage() {
        System.debug('📦 正在准备消息...');
    }

    // 抽象方法：由子类决定如何发送
    public abstract void sendNotification(String message);
}
```

#### 子类：实现不同的发送渠道

```apex
public class EmailNotification extends NotificationService {
    public EmailNotification(String r) {
        super(r);
    }

    public override void sendNotification(String message) {
        System.debug('📧 向 ' + recipient + ' 发送邮件：' + message);
    }
}

public class SmsNotification extends NotificationService {
    public SmsNotification(String r) {
        super(r);
    }

    public override void sendNotification(String message) {
        System.debug('📱 向 ' + recipient + ' 发送短信：' + message);
    }
}
```

#### 调用：

```apex
List<NotificationService> notifiers = new List<NotificationService>{
    new EmailNotification('user@demo.com'),
    new SmsNotification('138-0000-0000')
};

for (NotificationService n : notifiers) {
    n.prepareMessage();
    n.sendNotification('您的订单已发货');
}
```

---

### 🔹 使用场景：

| 场景                | 示例           |
| ----------------- | ------------ |
| 1️⃣ 想定义一个通用工作流程   | 如通知、审批、导入导出等 |
| 2️⃣ 强制子类实现特定行为    | 确保所有实现类结构统一  |
| 3️⃣ 有“部分通用逻辑”需要复用 | 可在父类中写公共部分   |

---

## 🧩 三、Interface（接口）

### 💡 概念

* **只定义规则，不写实现。**
* 类可以实现多个接口。
* 接口中只允许定义**方法签名**（声明），不允许写逻辑。

---

### 🧠 生活比喻

接口就像“合同 📄”：
公司规定你必须能提供某些功能，但具体怎么实现随你。

---

### ✅ 示例：记录操作标准接口

```apex
public interface IRecordHandler {
    void createRecord();
    void deleteRecord();
}
```

#### 不同模块实现接口：

```apex
public class AccountHandler implements IRecordHandler {
    public void createRecord() {
        System.debug('🏢 创建 Account 记录');
    }
    public void deleteRecord() {
        System.debug('🏢 删除 Account 记录');
    }
}

public class ContactHandler implements IRecordHandler {
    public void createRecord() {
        System.debug('👤 创建 Contact 记录');
    }
    public void deleteRecord() {
        System.debug('👤 删除 Contact 记录');
    }
}
```

#### 调用：

```apex
List<IRecordHandler> handlers = new List<IRecordHandler>{
    new AccountHandler(),
    new ContactHandler()
};

for (IRecordHandler h : handlers) {
    h.createRecord();
    h.deleteRecord();
}
```

输出：

```
🏢 创建 Account 记录
🏢 删除 Account 记录
👤 创建 Contact 记录
👤 删除 Contact 记录
```

---

### 🔹 使用场景：

| 场景               | 示例                                   |
| ---------------- | ------------------------------------ |
| 1️⃣ 不同模块需要统一接口   | 如各类 Trigger Handler 实现统一 `execute()` |
| 2️⃣ 想实现多继承       | 一个类可实现多个接口                           |
| 3️⃣ 想规范实现层与调用层解耦 | Controller 依赖接口而非具体实现                |

---

## 🧱 四、三者差异总结（项目实用视角）

| 特征         | Virtual Class        | Abstract Class        | Interface                 |
| ---------- | -------------------- | --------------------- | ------------------------- |
| 能否实例化      | ✅ 可以                 | ❌ 不行                  | ❌ 不行                      |
| 主要目的       | 允许扩展                 | 定义模板                  | 统一规范                      |
| 方法         | 可有默认实现               | 部分抽象，部分实现             | 全部声明                      |
| 属性         | ✅ 可定义                | ✅ 可定义                 | ⚠️ 仅常量                    |
| 使用关键词      | `virtual`, `extends` | `abstract`, `extends` | `interface`, `implements` |
| 体现的 OOP 特性 | 继承 + 多态              | 抽象 + 多态               | 抽象 + 解耦                   |
| 常见应用       | Handler 基类 / 工具类     | Service 模板 / 流程标准     | Trigger Handler 接口 / 策略模式 |

---

## 🧠 五、三者联合实战：统一触发器处理模型

```apex
// 接口：规定所有Handler必须有execute()
public interface ITriggerHandler {
    void execute();
}

// 抽象类：定义基础结构
public abstract class BaseHandler implements ITriggerHandler {
    public abstract void execute(); // 让子类实现
    public void logAction(String message) {
        System.debug('🧾 Log: ' + message);
    }
}

// 虚拟类：提供可扩展的默认逻辑
public virtual class AccountHandler extends BaseHandler {
    public override void execute() {
        logAction('处理 Account 数据中...');
        System.debug('🏢 AccountHandler 执行完毕');
    }
}

// 另一个实现
public class ContactHandler extends BaseHandler {
    public override void execute() {
        logAction('处理 Contact 数据中...');
        System.debug('👤 ContactHandler 执行完毕');
    }
}
```

#### 调用：

```apex
List<ITriggerHandler> handlers = new List<ITriggerHandler>{
    new AccountHandler(),
    new ContactHandler()
};
for (ITriggerHandler h : handlers) {
    h.execute();
}
```

---

### 🧩 总结一句话记忆：

| 类型                 | 一句话理解          |
| ------------------ | -------------- |
| **Virtual Class**  | “能直接用，也能继承改。”  |
| **Abstract Class** | “我定规则，你必须补全。”  |
| **Interface**      | “我只提要求，不管怎么做。” |

---

