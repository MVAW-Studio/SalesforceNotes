# 一、先来个直观比喻（Trigger 是啥？）

触发器就像 **门卫**：当有人（记录）要进数据库（insert/update/delete/undelete）时，门卫立刻检查并按规则处理（校验、补值、写关联记录、阻止保存等）。触发器分成在“进门前”（before）和“进门后”（after）两个时段做事 —— 前者可修改要保存的数据，后者则适合做依赖已持久化结果的操作（比如读取新记录的 Id 或调用外部系统）。

---

# 二、触发器的基本构成（以 Account 为例）

一个最简单的 Account trigger：

```apex
// AccountTrigger.trigger
trigger AccountTrigger on Account (
    before insert,
    before update,
    after insert,
    after update,
    after delete,
    after undelete,
    before delete
) {
    // 为了可维护性，实际逻辑建议放在 Handler（类）中
    AccountTriggerHandler.handleTrigger(Trigger.operationType, Trigger.isBefore, Trigger.isAfter, Trigger.new, Trigger.old, Trigger.newMap, Trigger.oldMap);
}
```


| 部分                                   | 含义    |
| ------------------------------------ | ----- |
| `trigger`                            | 固定关键字 |
| `AccountTrigger`                     | 触发器名  |
| `on Account`                         | 监听对象  |
| `(before insert, after update, ...)` | 触发时机  |
| `{ ... }`                            | 执行逻辑体 |



上面只是“壳”。实际业务逻辑由 `AccountTriggerHandler` 这种 handler 类来实现（下节会详细示例）。

---

# 三、官方 `Trigger` 类（上下文变量）— 都有什么？

Salesforce 在触发器上下文中提供了一套静态变量，位于 `System.Trigger`。常用的有：

* `Trigger.isBefore` / `Trigger.isAfter`：布尔，表示当前触发器是 before 还是 after。
* `Trigger.isInsert` / `Trigger.isUpdate` / `Trigger.isDelete` / `Trigger.isUndelete`：布尔，表示具体操作类型。
* `Trigger.new`：`List<sObject>`，包含触发操作后的新版本记录（`insert`/`update`/`undelete` 时可用）。**注意：在 delete 上下文 `Trigger.new` 为 null。**
* `Trigger.old`：`List<sObject>`，包含触发前的旧版本记录（`update`/`delete` 时可用）。**insert 时 `Trigger.old` 为 null。**
* `Trigger.newMap` / `Trigger.oldMap`：`Map<Id, sObject>`，按 Id 快速查找对应记录（在 insert 时 `newMap` 可用；在 delete 时 `oldMap` 可用）。
* `Trigger.isExecuting`：表示触发器是否正在执行（一般用得少）。
* `Trigger.operationType`：枚举 `System.TriggerOperation`，可用于更清晰的分支处理。

> 参考：官方 Trigger Context Variables 文档（变量一览与可用场景）。([Salesforce Developers][1])

---

# 四、一个推荐的工程化结构：**Trigger + Handler（单一触发器 + 处理类）**

**为什么？**

* 一个对象只保留一个 trigger（`One Trigger Per Object`），避免多个 trigger 竞争顺序。
* 把逻辑放在 handler 类里能更好分层、单测、重用、控制不同触发时机行为。

示例：`AccountTrigger` + `AccountTriggerHandler`

```apex
// AccountTrigger.trigger
trigger AccountTrigger on Account (
    before insert, before update, before delete,
    after insert, after update, after delete, after undelete
) {
    if (Trigger.isBefore) {
        if (Trigger.isInsert)  AccountTriggerHandler.beforeInsert(Trigger.new);
        if (Trigger.isUpdate)  AccountTriggerHandler.beforeUpdate(Trigger.new, Trigger.oldMap);
        if (Trigger.isDelete)  AccountTriggerHandler.beforeDelete(Trigger.old);
    } else if (Trigger.isAfter) {
        if (Trigger.isInsert)  AccountTriggerHandler.afterInsert(Trigger.new);
        if (Trigger.isUpdate)  AccountTriggerHandler.afterUpdate(Trigger.new, Trigger.oldMap);
        if (Trigger.isDelete)  AccountTriggerHandler.afterDelete(Trigger.old);
        if (Trigger.isUndelete) AccountTriggerHandler.afterUndelete(Trigger.new);
    }
}
```

```apex
// AccountTriggerHandler.cls
public class AccountTriggerHandler {
    // BEFORE INSERT 示例：在保存前设默认值并校验（可直接修改 Trigger.new 里的字段）
    public static void beforeInsert(List<Account> newList) {
        for (Account a : newList) {
            if (a.Name == null) {
                a.Name = 'Default Account Name'; // 合法：before 可以直接修改记录
            }
            // 示例校验
            if (a.Name != null && a.Name.length() > 255) {
                a.addError('Account Name too long'); // 阻止保存
            }
        }
    }

    // AFTER INSERT 示例：创建关联 Contact（需要 Account.Id，必须在 after insert 中）
    public static void afterInsert(List<Account> newList) {
        List<Contact> toInsert = new List<Contact>();
        for (Account a : newList) {
            Contact c = new Contact(LastName = a.Name + ' Contact', AccountId = a.Id);
            toInsert.add(c);
        }
        if (!toInsert.isEmpty()) {
            insert toInsert; // after insert 可以执行 DML 使用 Account.Id
        }
    }

    // BEFORE UPDATE 示例：举例对比旧值（一般用newMap和oldMap做差异判断）
    public static void beforeUpdate(List<Account> newList, Map<Id, Account> oldMap) {
        for (Account a : newList) {
            Account oldA = oldMap.get(a.Id);
            if (oldA != null && a.AnnualRevenue != oldA.AnnualRevenue) {
                // 做修改前的校验或自动调整
            }
        }
    }

    // AFTER UPDATE 示例
    public static void afterUpdate(List<Account> newList, Map<Id, Account> oldMap) {
        // 不能直接修改 newList（只读），如需修改必须执行额外 DML 或在 before update 修改
    }

    // BEFORE DELETE 示例
    public static void beforeDelete(List<Account> oldList) {
        for (Account a : oldList) {
            if (a.Name == 'DoNotDelete') {
                a.addError('This Account cannot be deleted');
            }
        }
    }

    // AFTER DELETE 示例
    public static void afterDelete(List<Account> oldList) {
        // 记录删除后处理，如写审计日志等
    }

    // AFTER UNDELETE 示例
    public static void afterUndelete(List<Account> newList) {
        // 记录恢复相关逻辑
    }
}
```

> 推荐实践与更深讨论（Trigger handler 框架）可参考社区/官方最佳实践。([Salesforce Ben][2])

---

# 五、触发时机（7 种）与 before/after 的核心区别
| 操作类型     | before | after | 说明      |
| -------- | ------ | ----- | ------- |
| insert   | ✅      | ✅     | 新建记录前后  |
| update   | ✅      | ✅     | 修改记录前后  |
| delete   | ✅      | ✅     | 删除记录前后  |
| undelete | ❌      | ✅     | 从回收站恢复后 |

## 7 种常见数据库事件（Trigger 可能绑定的事件）

1. `before insert`
2. `after insert`
3. `before update`
4. `after update`
5. `before delete`
6. `after delete`
7. `after undelete`

> 注意：Salesforce 也支持 `merge`、`upsert` 等情形，但“常见七种”如上（undelete 只有 after）。官方文档列出了这些事件与上下文变量。([Salesforce Developers][3])

---

## before vs after：根本差异

* **before**：在记录被写入数据库之前执行 —— *可直接修改 `Trigger.new` 中字段，省去额外 DML*（用于默认值、字段修正、简单校验）。
* **after**：在记录已被写入数据库之后执行 —— *可以读取记录的 Id、相关计算字段、执行需要已持久化数据的操作（如创建关联对象、发起通知、调用外部系统）*。在 after 上下文中 `Trigger.new`（或 `Trigger.newMap`）通常是只读的，不能直接修改记录来影响已完成的写入操作。([Salesforce Developers][1])

---

## 何时用 before？何时用 after？

### 用 `before` 的场景（示例）

* 要 **在保存前自动填充或修正字段**（节省一次 DML）
* 要 **阻止保存**（通过 `addError()`）
* 要 **对即将保存的数据进行格式化/简单计算**

示例：`before insert` 给 Account 的 `Phone` 格式化并设置默认值：

```apex
public static void beforeInsert(List<Account> newList) {
    for (Account a : newList) {
        if (String.isBlank(a.Phone)) {
            a.Phone = '000-000-0000'; // 直接赋值：会和保存一起生效
        } else {
            a.Phone = normalizePhone(a.Phone);
        }
    }
}
```

### 用 `after` 的场景（示例）

* 需要 **已存在的 Id**（例如：在 `after insert` 创建关联记录并用 `Account.Id` 作为外键）
* 需要 **读取触发后数据库计算或触发其他系统后产生的值**（例如自动计算字段、触发器链等）
* 需要进行 **异步或外部调用**（但要注意 callout 限制，通常通过 `@future` / Queueable 来做）

示例已在上面 handler 的 `afterInsert` 中体现（创建 Contact 并使用 `Account.Id`）。注意：在 `after` 中不能修改 `Trigger.new` 来改变已保存的记录，如果确实要修改数据库字段需要发起一个额外的 DML（或使用 `before` 做修改）。

---

# 六、使用 Trigger 的常见注意事项与坑

下面列出触发器常见的坑与如何避免（每条都有说明与示例）：

### 1) **before insert 中没有 Id**

* 说明：在 `before insert` 时，记录尚未写入数据库，因此 `Id` 为空（不能依赖它做关联）。
* 解决：如果需要 `Id`（例如创建子记录并设置父 Id），请在 `after insert` 中执行（`after insert` 中 `Id` 可用）。

```apex
// 错误用法（不要在 before insert 中依赖 Id）
for (Account a : Trigger.new) {
    if (a.Id != null) { /* 不可靠 */ }
}
```

### 2) **after 中 Trigger.new 是只读**

* 说明：在 `after` 语境修改 `Trigger.new` 的字段会抛异常（只读）。
* 解决：要变更字段，应该在 `before` 时修改，或在 `after` 时执行额外的 DML（update）来修改记录。

```apex
// 错误：在 after insert 里直接修改会报错
for (Account a : Trigger.new) {
    a.Custom_Field__c = 'new'; // 在 after 中这是只读（会抛异常）
}
// 正确：在 before insert 修改，或 after insert 使用 update
```

### 3) **触发器必须支持批量（Bulkify）**

* 说明：一次 DML 操作可能包含多条记录（批量），Trigger 里的代码必须以集合方式写，避免在循环内执行 SOQL/DML。
* 解决：把 SOQL/DML 移出循环，使用 Map、Set 批量处理。

```apex
// 错误（在循环里做 SOQL）——会触发 governor limit
for (Account a : Trigger.new) {
    Contact c = [SELECT Id FROM Contact WHERE AccountId = :a.Id LIMIT 1]; // ← 错
}

// 正确（先收集 Id，一次性查询）
Set<Id> accIds = new Set<Id>();
for (Account a : Trigger.new) accIds.add(a.Id);
Map<Id, Contact> contactMap = new Map<Id, Contact>();
for (Contact c : [SELECT Id, AccountId FROM Contact WHERE AccountId IN :accIds]) {
    contactMap.put(c.AccountId, c);
}
```

### 4) **不要在触发器中直接写复杂逻辑（保持逻辑清晰）**

* 建议把业务逻辑拆到 handler 服务类里，不在 trigger 文件放实现细节（方便单元测试与复用）。

### 5) **Trigger.old 的可用时机与 delete 特别情况**

* `Trigger.old` 在 `update`/`delete` 时可用；在 `insert` 时为 null。
* 在 `delete` 时，`Trigger.new` 为 null；只能使用 `Trigger.old`/`Trigger.oldMap`。

### 6) **使用 addError 阻止 DML**

* 可以在 before 场景用 `sObject.addError('msg')` 阻止单条或整批保存，常用于复杂校验。

### 7) **避免在触发器中做 Callout（HTTP）——除非异步**

* 触发器本身不能直接做同步 callout；需要用 `@future(callout=true)` 或 `Queueable` 来包装。

### 8) **混合 DML（Mixed DML）限制**

* 在同一事务中同时对某些对象（例如 User 与普通 sObject）进行 DML 可能受到混合 DML 限制，需要注意并用异步方式规避。

---

# 七、Governor Limits（关键项）

下面列出 **在触发器/单次事务** 中最常遇到、且与触发器实现直接相关的一些重要平台限制（以便在设计 handler 时避免越界）。这些限制来源于 Salesforce 官方文档（建议作为权威参考）。([Salesforce Developers][4])

#  Governor Limits

> Salesforce 是多租户架构（多个客户共用资源）。
> 为了防止单个程序“吃掉所有资源”，系统对每个事务设置了限额。

| 限制类型           | 最大值         | 说明                               |
| -------------- | ----------- | -------------------------------- |
| SOQL 查询        | 100 次       | 一次事务最多执行100次查询                   |
| DML 操作         | 150 次       | insert/update/delete/undelete 总和 |
| 每次 SOQL 返回的记录数 | 50,000 条    | 超过会报错                            |
| CPU 时间         | 10,000 ms   | 超过会中断执行                          |
| 递归触发器          | 无限 → 应该人工限制 | 防止循环触发                           |
| 查询集合大小         | 50,000 条    | 结果集不能太大                          |

**避免超限的技巧：**

* 合并 DML 操作（批量插入）
* 合并 SOQL 查询（把查询放循环外）
* 用 `Set`、`Map` 存储中间结果
* 使用异步方法（Queueable、Future）

---

##  举例：正确与错误示范

### ❌ 错误写法（循环中查询）

```apex
for (Account acc : Trigger.new) {
    List<Contact> cons = [SELECT Id FROM Contact WHERE AccountId = :acc.Id];
}
```

### ✅ 正确写法（合并查询）

```apex
Set<Id> accIds = new Set<Id>();
for (Account acc : Trigger.new) accIds.add(acc.Id);

Map<Id, List<Contact>> accToContacts = new Map<Id, List<Contact>>();
for (Contact c : [SELECT Id, AccountId FROM Contact WHERE AccountId IN :accIds]) {
    if (!accToContacts.containsKey(c.AccountId)) accToContacts.put(c.AccountId, new List<Contact>());
    accToContacts.get(c.AccountId).add(c);
}
```



---

# 八、把前面的知识整合成几个实战用例

下面给几个常见真实场景，用 Account 举例，代码都贴完整并逐行注释。

## 用例 1 — 在 `before insert` 自动填充字段 & 简单校验（避免额外 DML）

```apex
public class AccountTriggerHandler {
    public static void beforeInsert(List<Account> newAccounts) {
        for (Account a : newAccounts) {
            // 1) 如果没有 Industry，设默认
            if (String.isBlank(a.Industry)) {
                a.Industry = 'Unknown'; // before 可以直接赋值
            }
            // 2) 校验：禁止名字为空
            if (String.isBlank(a.Name)) {
                a.addError('Account Name must be provided'); // 阻止保存
            }
        }
    }
}
```

## 用例 2 — 在 `after insert` 创建关联 Contact（必须使用 after，因为需要 Account.Id）

```apex
public class AccountTriggerHandler {
    public static void afterInsert(List<Account> newAccounts) {
        List<Contact> contactsToInsert = new List<Contact>();
        for (Account a : newAccounts) {
            // a.Id 在 after insert 中已存在，可以用作外键
            contactsToInsert.add(new Contact(
                LastName = a.Name != null ? a.Name + ' Contact' : 'Default Contact',
                AccountId = a.Id
            ));
        }
        if (!contactsToInsert.isEmpty()) {
            insert contactsToInsert; // 在 after 中做 DML 创建关联记录
        }
    }
}
```

## 用例 3 — bulk-safe 的 `before update`：只对变化的字段执行逻辑（使用 oldMap 做比对）

```apex
public class AccountTriggerHandler {
    public static void beforeUpdate(List<Account> newAccounts, Map<Id, Account> oldMap) {
        for (Account a : newAccounts) {
            Account oldA = oldMap.get(a.Id);
            if (oldA != null && oldA.AnnualRevenue != a.AnnualRevenue) {
                // 只在 AnnualRevenue 变更时进行某些检查或自动计算
                if (a.AnnualRevenue != null && a.AnnualRevenue < 0) {
                    a.addError('Annual Revenue cannot be negative');
                }
            }
        }
    }
}
```

## 用例 4 — 在 `after delete` 写审计日志（使用 Trigger.old）

```apex
public class AccountTriggerHandler {
    public static void afterDelete(List<Account> oldAccounts) {
        List<Your_Audit__c> logs = new List<Your_Audit__c>();
        for (Account a : oldAccounts) {
            logs.add(new Your_Audit__c(
                Name = 'Delete Account: ' + a.Name,
                Account_Id__c = a.Id
            ));
        }
        if (!logs.isEmpty()) insert logs;
    }
}
```
---
##  Apex 触发器执行流程（Order of Execution）

> Salesforce 在保存一条记录时，会经过一条“生产线”，
> 每个环节都有机器在加工，比如 trigger、workflow、process builder、flow 等。
>
> 这条生产线就是「Order of Execution」。


##  整体流程图

下面是官方执行顺序的**结构化图**（含 trigger、flow、rollup、workflow 等）。

```
┌────────────────────────────────────────────┐
│                DML 操作开始                │
│ （例如 insert / update / delete）          │
└────────────────────────────────────────────┘
                 │
                 ▼
───────────────────────────────────────────────
① 系统验证阶段（System Validation）
   - 检查字段类型、必填项、格式等。
───────────────────────────────────────────────
② BEFORE 触发器（before trigger）
   - before insert / before update / before delete
   - 可修改 Trigger.new 中的数据
───────────────────────────────────────────────
③ 系统验证规则（Validation Rules）
   - 执行验证规则（record 级别）
───────────────────────────────────────────────
④ 执行 DML 操作（写入数据库，但未提交）
   - 系统准备好要写入的记录（暂存在内存）
───────────────────────────────────────────────
⑤ AFTER 触发器（after trigger）
   - after insert / after update / after delete
   - Trigger.new 中的数据已写入数据库
   - 此时 Id 已经生成（insert 后）
───────────────────────────────────────────────
⑥ 执行 Assignment Rules（如 Lead 转换分配）
───────────────────────────────────────────────
⑦ 执行 Auto-Response Rules（自动回复规则）
───────────────────────────────────────────────
⑧ 执行 Workflow Rules（工作流规则）
   - 如果更新了记录，会触发二次更新（retrigger）
───────────────────────────────────────────────
⑨ 执行 Process Builder / Flows（自动化流程）
   - 注意：会再次触发 before/after trigger
───────────────────────────────────────────────
⑩ 执行 Roll-up Summary（汇总字段更新）
   - 可能导致父对象再次触发 trigger
───────────────────────────────────────────────
⑪ 提交前（Before Commit）
   - 执行 Escalation Rules / Entitlement Rules
───────────────────────────────────────────────
⑫ DML 提交（Commit）
   - 数据真正写入数据库
───────────────────────────────────────────────
⑬ 执行 Post-commit 逻辑
   - 异步操作（@future、Queueable、Email 发送、Async Apex）
───────────────────────────────────────────────
```


