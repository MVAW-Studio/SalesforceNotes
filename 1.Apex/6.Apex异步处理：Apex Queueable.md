
# 🧱 Apex Queueable 类

## 🎯 一句话理解 Queueable 是什么

> **Queueable Apex** 就像 Salesforce 中的「**打工队列**」。
> 你把一件要做的任务（比如寄信、更新数据、生成报表）交给队列，说：
> “这件事我现在不想做，让后台帮我慢慢做。”

Salesforce 就会：

* 把任务放进一个「排队机」；
* 系统空闲时自动执行；
* 你可以同时安排很多任务（批量后台处理）。

---

## 🧩 一、类比：普通类 vs Queueable 类

| 类型          | 比喻             | 特点                       |
| ----------- | -------------- | ------------------------ |
| 普通类         | 你自己手动做家务       | 代码立即执行，等它完成后才能做别的事       |
| Queueable 类 | 请了一个清洁工队列帮你做家务 | 你只要交代任务，它会后台慢慢完成，不影响你做别的 |

---

## 🧱 二、要点一：Queueable 要实现的接口

在 Apex 里，**Queueable 是一个接口**，名字叫：

```apex
Queueable
```

当我们写一个类要“放进队列”时，**必须实现这个接口**。

> 就像你要请清洁工上岗，必须签个合同（实现接口），告诉他该做什么。

---

### ✨ 代码例子 ①：最简单的 Queueable 类

```apex
public class MyFirstQueue implements Queueable {
    public void execute(QueueableContext context) {
        // 这里写要后台执行的内容
        System.debug('🎯 后台开始执行任务啦！');
    }
}
```

解释一下：

* `implements Queueable`：表示这个类能放进队列；
* `execute()`：系统自动调用的入口（相当于任务的“说明书”）；
* `QueueableContext context`：系统传进来的上下文信息，一般用来取 Job ID。

---

## 🚀 三、怎么“排队执行”

写好类以后，要让系统执行，就用这个语句：

```apex
ID jobId = System.enqueueJob(new MyFirstQueue());
```

这就像你打电话给清洁工公司：“我有个活要做”。
系统会返回一个 **Job ID**，你可以用它去查看执行状态。

---

### ✨ 代码例子 ②：完整示例

```apex
public class MyFirstQueue implements Queueable {
    public void execute(QueueableContext context) {
        System.debug('🎯 后台任务执行中...');
        // 模拟业务逻辑：比如更新一些记录
        List<Account> accs = [SELECT Id, Name FROM Account LIMIT 5];
        for (Account a : accs) {
            a.Name = a.Name + '✅';
        }
        update accs;
        System.debug('✅ 更新完成！');
    }
}

// 在执行 Anonymous Window 或触发器中调用：
ID jobId = System.enqueueJob(new MyFirstQueue());
System.debug('任务加入队列，JobId=' + jobId);
```

---

## ⚙️ 四、Queueable 的常见用途

| 用途            | 说明              |
| ------------- | --------------- |
| 🔄 批量更新数据     | 比如处理 10,000 条记录 |
| 📨 调用外部系统 API | 防止同步超时          |
| 🕓 延时执行       | 避免触发器递归或逻辑冲突    |
| 🧮 报表计算       | 大型计算可异步执行       |

---

## 🪄 五、Queueable 可以传参数！

Queueable 的一个大优点是：**可以传自定义参数！**

比如我们想告诉清洁工“要打扫哪个房间”：

### ✨ 代码例子 ③：带参数的 Queueable

```apex
public class MyParamQueue implements Queueable {
    private String roomName;

    public MyParamQueue(String roomName) {
        this.roomName = roomName;
    }

    public void execute(QueueableContext context) {
        System.debug('正在清扫房间：' + roomName);
    }
}

// 调用：
System.enqueueJob(new MyParamQueue('会议室'));
```

输出：

```
正在清扫房间：会议室
```

---

## 🔁 六、Queueable 可以「接力排队」

> 就像一个清洁工干完活后，把下一项任务交给另一个人继续做。

在 `execute()` 里可以再加一个新的队列任务：

### ✨ 代码例子 ④：链式队列

```apex
public class FirstJob implements Queueable {
    public void execute(QueueableContext context) {
        System.debug('🧹 第一个任务完成，开始第二个任务');
        System.enqueueJob(new SecondJob());
    }
}

public class SecondJob implements Queueable {
    public void execute(QueueableContext context) {
        System.debug('🧽 第二个任务执行中...');
    }
}
```

---

## ⚠️ 七、使用限制与注意点

| 项目        | 限制说明                                         |
| --------- | -------------------------------------------- |
| 🕓 同时运行数量 | 每个组织同时最多 50 个正在执行的 Queueable 任务              |
| 🧩 嵌套     | 在一个 Queueable 任务中只能再启动**一个**新的 Queueable     |
| ⏳ 执行时间    | 每个任务最长 60 秒（跟异步 Apex 的系统限制一致）                |
| 💾 数据事务   | 任务是独立事务，不能与原请求共享 DML 上下文                     |
| 🧠 触发器中使用 | 建议通过 Future/Platform Event 或异步触发调用 Queueable |

---

## 🧰 八、Queueable 与其他异步方式的区别

| 异步方式          | 是否能传参         | 是否可链式调用 | 是否可监控状态        |
| ------------- | ------------- | ------- | -------------- |
| Future        | ✅ 有限制（只能基本类型） | ❌ 不行    | ❌ 不行           |
| Batch         | ✅ 可以          | ✅ 批次内可控 | ✅ 可            |
| **Queueable** | ✅ 可以传对象       | ✅ 可以    | ✅ 可以（通过 JobId） |

---

## 🧾 九、查看执行结果

你可以在 **Salesforce 设置 → Apex Jobs** 页面查看任务状态：

* Status：Queued / Processing / Completed / Failed
* Job ID：和 `System.enqueueJob()` 返回的相同
* Apex Class：对应你的类名

---

## 🧠 十、总结一句话口诀

> **Queueable 就是“能排队执行、能传参、能接力”的后台任务类。**

写的时候记住三件事：

```text
1️⃣ implements Queueable
2️⃣ public void execute(QueueableContext context)
3️⃣ 用 System.enqueueJob(new YourClass());
```

---

## ✅ 完整范例：从 0 到执行

```apex
// 1️⃣ 定义一个 Queueable 类
public class SendEmailQueue implements Queueable {
    private String targetEmail;
    public SendEmailQueue(String email) {
        this.targetEmail = email;
    }

    public void execute(QueueableContext context) {
        System.debug('📩 向 ' + targetEmail + ' 发送邮件中...');
        // 模拟邮件逻辑
        // Messaging.sendEmail(...);
    }
}

// 2️⃣ 在执行匿名窗口中运行
ID jobId = System.enqueueJob(new SendEmailQueue('test@example.com'));
System.debug('任务加入队列，Job ID=' + jobId);
```

---

## 💡 你可以这样理解

> 普通类是“自己干活”；
> Future 是“打电话请人干”；
> **Queueable 是：打电话请人干 + 还能带工具 + 能安排下一项任务。**

